-- This file has been generated by CocoSim compiler + verifier

type complex_real = struct { r: real; i: real};
-- Extern functions
node sqrt(in1 : real)
returns (out1 : real);
let
--!C_Code: math.c/sqrt;
tel


-- System nodes
node signum_test (In1_1_1 : complex_real; In1_1_2 : complex_real; In1_1_3 : complex_real; In2_1_1 : real; In2_1_2 : real; In2_1_3 : real; In4_1_1 : int; In4_1_2 : int; In4_1_3 : int; )
returns (Out1_1_1 : complex_real; Out1_1_2 : complex_real; Out1_1_3 : complex_real;
	Out2_2_1 : real; Out2_2_2 : real; Out2_2_3 : real;
	Out4_3_1 : int; Out4_3_2 : int; Out4_3_3 : int) 
var
	Sign_1_1 : complex_real; Sign_1_2 : complex_real; Sign_1_3 : complex_real;
	Sign1_1_1 : real; Sign1_1_2 : real; Sign1_1_3 : real;
	Sign3_1_1 : int; Sign3_1_2 : int; Sign3_1_3 : int;
let 
	Sign_1_1.r = In1_1_1.r / sqrt(In1_1_1.r * In1_1_1.r + In1_1_1.i * In1_1_1.i);
	Sign_1_2.r = In1_1_2.r / sqrt(In1_1_2.r * In1_1_2.r + In1_1_2.i * In1_1_2.i);
	Sign_1_3.r = In1_1_3.r / sqrt(In1_1_3.r * In1_1_3.r + In1_1_3.i * In1_1_3.i);
	Sign1_1_1 = if In2_1_1 = 0.0 then 0.0 else if In2_1_1 < 0.0 then -1.0 else 1.0;
	Sign1_1_2 = if In2_1_2 = 0.0 then 0.0 else if In2_1_2 < 0.0 then -1.0 else 1.0;
	Sign1_1_3 = if In2_1_3 = 0.0 then 0.0 else if In2_1_3 < 0.0 then -1.0 else 1.0;
	Sign3_1_1 = if In4_1_1 = 0 then 0 else if In4_1_1 < 0 then -1 else 1;
	Sign3_1_2 = if In4_1_2 = 0 then 0 else if In4_1_2 < 0 then -1 else 1;
	Sign3_1_3 = if In4_1_3 = 0 then 0 else if In4_1_3 < 0 then -1 else 1;
	Out1_1_1 = Sign_1_1;
	Out1_1_2 = Sign_1_2;
	Out1_1_3 = Sign_1_3;
	Out2_2_1 = Sign1_1_1;
	Out2_2_2 = Sign1_1_2;
	Out2_2_3 = Sign1_1_3;
	Out4_3_1 = Sign3_1_1;
	Out4_3_2 = Sign3_1_2;
	Out4_3_3 = Sign3_1_3;
	--!MAIN: true;
tel

